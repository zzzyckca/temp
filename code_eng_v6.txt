import win32com.client
import os
import shutil
import pandas as pd
import pythoncom
from datetime import datetime

# ==========================================
# 1. CONFIGURATION & SETUP
# ==========================================
# The specific account to monitor. Must match the Outlook display name exactly.
TARGET_ACCOUNT_NAME = "data.team@rbc.com"

# Local File System Paths
CONFIG_FILE_PATH = r"C:\Work\config.xlsx"   # Excel rule file
TEMP_FOLDER = r"C:\temp3"                   # Staging area for downloads
DEFAULT_FOLDER = r"C:\temp4"                # Fallback destination if no rule matches

# Database Configuration
# ‚ö†Ô∏è REPLACE THIS with your actual SQLAlchemy engine object before running
# Example: create_engine('mssql+pyodbc://user:pwd@host/db?driver=ODBC+Driver+17+for+SQL+Server')
create_engine = "REPLACE_WITH_REAL_ENGINE_OBJECT" 
DB_TABLE_NAME = "Email_Automation_Logs"

# Ensure all necessary local directories exist to prevent 'PathNotFound' errors
for f in [TEMP_FOLDER, DEFAULT_FOLDER]:
    os.makedirs(f, exist_ok=True)


# ==========================================
# 2. HELPER FUNCTIONS
# ==========================================

def get_target_inbox(account_name):
    """
    Connects to the Outlook MAPI namespace and retrieves the 'Inbox' folder
    for a specific account name.
    
    Args:
        account_name (str): The display name of the email account (e.g., 'data.team@rbc.com')
    
    Returns:
        Outlook.MAPIFolder: The Inbox folder object, or None if not found.
    """
    # Initialize COM library. Critical for thread safety if this script is run via task scheduler or Prefect.
    pythoncom.CoInitialize()
    
    outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
    
    # Loop through all root folders (Accounts) to find the match
    for folder in outlook.Folders:
        # Case-insensitive comparison for robustness
        if folder.Name.lower() == account_name.lower():
            try:
                # Direct access to 'Inbox' as requested (assuming English environment)
                return folder.Folders("Inbox")
            except Exception as e:
                print(f"‚ùå Account '{account_name}' found, but 'Inbox' folder is missing: {e}")
                return None
                
    print(f"‚ùå Could not find any account matching: {account_name}")
    return None


def load_config_rules():
    """
    Reads the automation rules from Excel.
    
    Expected Columns:
    - Subject_Keyword: Substring to look for in Email Subject.
    - Attachment_Keyword: Substring to look for in Filename.
    - File_Extension: Specific file type (e.g., '.pdf').
    - Destination_Folder: Where to move the file.
    """
    try:
        df = pd.read_excel(CONFIG_FILE_PATH)
        
        # Data Cleaning: Fill NaN with empty strings to prevent 'float' errors during string comparison
        df.fillna("", inplace=True)
        
        # Validation: Ensure all required columns exist
        expected_cols = ['Subject_Keyword', 'Attachment_Keyword', 'File_Extension', 'Destination_Folder']
        for col in expected_cols:
            if col not in df.columns:
                # Add missing column with empty values to prevent KeyError later
                df[col] = "" 
        
        # Convert to list of dictionaries for faster iteration
        rules = df.to_dict('records')
        print(f"üìã Loaded {len(rules)} rules from {CONFIG_FILE_PATH}")
        return rules
        
    except Exception as e:
        print(f"‚ùå Critical Error: Failed to load config excel. Reason: {e}")
        return []


def process_attachments(msg, rules, logs_list):
    """
    Core Logic:
    1. Iterates through all attachments in a single email.
    2. Downloads them to a temp folder.
    3. Matches them against Excel rules.
    4. Moves them to the final destination.
    5. Appends execution details to 'logs_list'.
    """
    # Safety Check: Skip if no attachments
    if msg.Attachments.Count == 0:
        return

    # Attempt to get sender name, handle cases where property might be missing (e.g., system notifications)
    try:
        sender_name = msg.SenderName
    except:
        sender_name = "Unknown"

    # Iterate through attachments (Outlook index starts at 1)
    for i in range(1, msg.Attachments.Count + 1):
        attachment = msg.Attachments.Item(i)
        filename = attachment.FileName
        
        # --- PHASE 1: DOWNLOAD TO TEMP ---
        # win32com requires an absolute path to save files. We use a temp folder first
        # to ensure we have the file on disk before trying to move it to a potentially network drive.
        temp_path = os.path.join(TEMP_FOLDER, filename)
        
        try:
            attachment.SaveAsFile(temp_path)
        except Exception as e:
            print(f"   ‚ùå Failed to save attachment '{filename}': {e}")
            # Log the failure
            logs_list.append({
                "Execution_Time": datetime.now(),
                "Email_Subject": msg.Subject,
                "Sender": sender_name,
                "Attachment": filename,
                "Status": "Failed (Save)",
                "Destination": "",
                "Matched_Rule": str(e)
            })
            continue # Skip to next attachment

        # --- PHASE 2: MATCH RULES ---
        destination = DEFAULT_FOLDER
        matched_rule_info = "Default (No Match)"

        for rule in rules:
            # Normalize inputs to lowercase for consistent matching
            r_subj = str(rule.get('Subject_Keyword', '')).strip().lower()
            r_att  = str(rule.get('Attachment_Keyword', '')).strip().lower()
            r_ext  = str(rule.get('File_Extension', '')).strip().lower() 
            r_dest = rule.get('Destination_Folder')

            # Logic: Match Subject AND Filename AND Extension
            match_subject = r_subj in msg.Subject.lower()
            match_filename = r_att in filename.lower()
            
            # Handle Extension: If rule is empty, accept any extension
            match_ext = filename.lower().endswith(r_ext) if r_ext else True

            if match_subject and match_filename and match_ext:
                destination = r_dest
                matched_rule_info = f"Rule: Subj='{r_subj}', Ext='{r_ext}'"
                break # Stop searching, we found the highest priority rule

        # --- PHASE 3: MOVE TO DESTINATION ---
        try:
            # Ensure destination folder exists (Create it if missing)
            os.makedirs(destination, exist_ok=True)
            
            final_path = os.path.join(destination, filename)
            
            # Move the file (Overwrite if exists - standard shutil behavior)
            shutil.move(temp_path, final_path)
            
            print(f"   ‚úÖ Processed: {filename} -> {destination}")
            
            # Log Success
            logs_list.append({
                "Execution_Time": datetime.now(),
                "Email_Subject": msg.Subject,
                "Sender": sender_name,
                "Attachment": filename,
                "Status": "Success",
                "Destination": final_path,
                "Matched_Rule": matched_rule_info
            })
            
        except Exception as e:
            print(f"   ‚ùå Failed to move file to {destination}: {e}")
            # Log Failure
            logs_list.append({
                "Execution_Time": datetime.now(),
                "Email_Subject": msg.Subject,
                "Sender": sender_name,
                "Attachment": filename,
                "Status": "Failed (Move)",
                "Destination": destination,
                "Matched_Rule": str(e)
            })


# ==========================================
# 3. MAIN EXECUTION FLOW
# ==========================================

def run_email_processor():
    print("üöÄ Starting Email Automation Script...")
    
    # 1. Load Rules
    rules = load_config_rules()
    if not rules:
        print("‚ö†Ô∏è Stopping: No rules loaded.")
        return

    # 2. Connect to Outlook
    inbox = get_target_inbox(TARGET_ACCOUNT_NAME)
    if not inbox: 
        print("‚ö†Ô∏è Stopping: Inbox not found.")
        return

    # 3. Retrieve Unread Emails
    # We restrict the query to the server side for performance
    items = inbox.Items.Restrict("[UnRead] = True")
    items.Sort("[ReceivedTime]", True) # Sort by Newest First

    print(f"üîç Found {items.Count} unread emails. Scanning for relevant subjects...")

    processed_count = 0
    audit_logs = [] # Initialize empty list for logging
    
    # ‚ö†Ô∏è CRITICAL: We use list(items) to create a snapshot of the emails.
    # Why? modifying the collection (e.g., changing UnRead status) while iterating 
    # directly over the 'items' COM object can cause index shifting and skip emails.
    for msg in list(items):
        try:
            # --- Step A: Relevance Check (Optimization) ---
            # Don't download attachments if the subject doesn't match ANY rule.
            is_relevant = False
            for rule in rules:
                rule_subj = str(rule.get('Subject_Keyword', '')).strip().lower()
                # Check if rule subject keyword is present in email subject
                if rule_subj and rule_subj in msg.Subject.lower():
                    is_relevant = True
                    break
            
            if not is_relevant:
                # Skip irrelevant emails entirely
                continue

            # --- Step B: Process Attachments ---
            print(f"üìß processing Relevant Email: {msg.Subject}")
            process_attachments(msg, rules, audit_logs)
            
            # --- Step C: Mark as Read ---
            # As per requirement: If subject matches, mark read regardless of attachment outcome
            msg.UnRead = False
            msg.Save() # Explicitly save the change state
            processed_count += 1
            print("   ‚ú® Marked as Read.")

        except Exception as e:
            print(f"‚ö†Ô∏è Error processing email object: {e}")

    # ==========================================
    # 4. LOGGING & DATABASE UPLOAD
    # ==========================================
    print(f"\nüèÅ Batch Finished. Total Emails Processed: {processed_count}")

    # Only attempt upload if there are actual logs
    if processed_count >= 1 and len(audit_logs) > 0:
        print("üìä Preparing Audit Logs...")
        
        df_log = pd.DataFrame(audit_logs)
        
        # Print sample to console for quick verification
        print("--- Log Preview ---")
        print(df_log.head(3)) 
        print(f"Total Records: {len(df_log)}")

        # --- DB Upload ---
        try:
            print(f"‚è≥ Uploading to Database Table: {DB_TABLE_NAME}...")
            
            # Using 'append' to add new rows without deleting old history
            # index=False ensures we don't upload the Pandas row numbers
            df_log.to_sql(DB_TABLE_NAME, con=create_engine, if_exists='append', index=False)
            
            print("‚úÖ Database Upload Successful.")
            
        except Exception as db_err:
            print(f"‚ùå DATABASE UPLOAD FAILED: {db_err}")
            print("üí° Check your 'create_engine' object and network connection.")
    else:
        print("‚ÑπÔ∏è No relevant activity to log this run.")

if __name__ == "__main__":
    run_email_processor()