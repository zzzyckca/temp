import pandas as pd
from TM1py import TM1Service

# ==========================================
# 1. Connection and File Configuration
# ==========================================
EXCEL_FILE = 'input_params.xlsx'       
OUTPUT_FILE = 'final_result_dynamic.csv'

# TM1 Connection Settings
TM1_CONFIG = {
    'address': 'localhost',
    'port': 12345,
    'user': 'admin',
    'password': 'password',
    'ssl': True
}
CUBE_NAME = "cb_reporting" 

# ==========================================
# 2. Read Excel & Auto-classify Dimensions
# ==========================================
print("--- 1. Reading Excel ---")
df_master = pd.read_excel(EXCEL_FILE)
df_master = df_master.astype(str)

# Clean Headers: Convert to lowercase + strip whitespace
# This ensures column names match TM1 dimension names (case-insensitive)
df_master.columns = df_master.columns.str.lower().str.strip()

# Remove duplicate columns if any
df_master = df_master.loc[:, ~df_master.columns.duplicated()]

print(f"All Excel Columns: {df_master.columns.tolist()}")

# üî• Core Logic: Verify 'measure' column exists
if 'measure' not in df_master.columns:
    raise ValueError("‚ùå Error: Column [measure] not found in Excel! Please ensure Excel Header contains 'measure'.")

# A. Separate Measure and Row Dimensions
measure_col = 'measure'

# Logic: All columns in Excel EXCEPT 'measure' are treated as Row Dimensions
# Since 'time_period' is now in Excel, it is automatically included here.
row_dims = [col for col in df_master.columns if col != measure_col]

print(f"üëâ Measure Axis (Columns): ['{measure_col}']")
print(f"üëâ Row Axis     (Rows)   : {row_dims}")

# ==========================================
# 3. Dynamically Assemble MDX
# ==========================================
print("--- 2. Assembling MDX ---")

# A. Measure (On 0 / Columns)
unique_measures = [x for x in df_master[measure_col].unique() if x]
# Assuming TM1 Dimension name for measure is 'measure'
str_measures = "{" + ",".join([f"[measure].[{item}]" for item in unique_measures]) + "}"

# B. Rows (On 1 / Rows) - All remaining columns (Account, Time, Dept, etc.)
row_mdx_parts = []
for dim in row_dims:
    # Get unique items for this dimension from the Excel column
    unique_items = [x for x in df_master[dim].unique() if x]
    
    if unique_items:
        # Syntax: [Dimension].[Element]
        # This works for Time_Period too (e.g., [time_period].[2025.01])
        mdx_set = "{" + ",".join([f"[{dim}].[{item}]" for item in unique_items]) + "}"
        row_mdx_parts.append(mdx_set)

# CrossJoin all row dimensions
row_mdx_str = " * ".join(row_mdx_parts)

# Construct Full MDX Query
mdx_query = f"""
SELECT
    {str_measures} ON 0,
    ( {row_mdx_str} ) ON 1
FROM [{CUBE_NAME}]
"""

# print(mdx_query) # Uncomment for debugging

# ==========================================
# 4. Execute Query & Merge
# ==========================================
print("--- 3. Executing Query ---")
df_tm1 = pd.DataFrame()

with TM1Service(**TM1_CONFIG) as tm1:
    df_tm1 = tm1.cells.execute_mdx_dataframe(mdx_query)
    
    # Reset Index & Clean Headers
    df_tm1 = df_tm1.reset_index()
    df_tm1.columns = df_tm1.columns.str.lower().str.strip()

if not df_tm1.empty:
    print("--- 4. Merge Data ---")
    
    # 1. Identify Value Column and rename to 'tm1_value'
    target_val_col = None
    
    # Priority 1: Check for 'value' or 'values'
    for col in ['value', 'values']:
        if col in df_tm1.columns: target_val_col = col; break
    
    # Priority 2: Check for specific measure names (e.g., mx_2)
    if not target_val_col:
        for m in unique_measures:
            if m.lower() in df_tm1.columns: target_val_col = m.lower(); break
            
    # Priority 3: Fallback to the last column
    if not target_val_col: target_val_col = df_tm1.columns[-1]

    df_tm1.rename(columns={target_val_col: 'tm1_value'}, inplace=True)

    # 2. Prepare Join Keys
    # We join using all Row Dimensions present in the returned data
    join_keys = [d for d in row_dims if d in df_tm1.columns]
    
    # Ensure all keys are strings for safe merging
    for col in join_keys:
        df_tm1[col] = df_tm1[col].astype(str)

    # 3. Perform Left Join
    # Master (Excel) Left Join TM1 Data
    final_df = pd.merge(
        df_master,
        df_tm1[join_keys + ['tm1_value']],
        how='left',
        on=join_keys
    )
    
    # Fill NaN values with 0
    final_df['tm1_value'] = final_df['tm1_value'].fillna(0)
    
    final_df.to_csv(OUTPUT_FILE, index=False)
    print(f"üéâ Success! Results saved to: {OUTPUT_FILE}")
    print(final_df.head())

else:
    print("‚ö†Ô∏è No results found (Check if Excel data matches Cube dimensions).")
